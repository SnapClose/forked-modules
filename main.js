#!/usr/bin/env node

const HELP_MSG = `iigen [src-dir-path] [output] [list-extensions]

Get the list of the file just contained in the passed source directory path (no
recurse the subdirectories) and generates "index" files which exports a list of
objects with the file name (just the name with the extension but without the
path) and the exported stuff.

The [ouput] parameter is optional an it's the file path used to write the
generated "index" file, otherwise a temporary file is generated.

The third parameter [list-extensions] is optional and only can be provided if
the [output] parameters is provided; it's a list of file extensions, comma
separated (with no spaces) which are considered to be Javascript modules, js by
default.

The command print out to the stdout the path to the autogenerated "index" file.

Example:
if the list of files in "my-src/components/" directory is
 - module.js
 - auth.vue
 - ignoreme

executing: iigen my-src/components components-index.js js,vue

The command will output in the stdout 'components-index.js' and will generate
such file with the next content:

import * as i0 from './my-src/components/auth.vue'
import * as i1 from './my-src/components/module.js'
export default [{ filename: 'auth.vue', exported: i0 }, { filename: 'module.js', exported: i1 }]


NOTE the tool doens't check the content of the files, so they are assumed to be
wel formatted Javascript modules
`

const fs = require('fs')
const path = require('path')
const relative = require('relative')

if (process.argv.length < 3) {
  exitWithError(`Error: the source directory path is required.

${HELP_MSG}
  `)
}

const srcDir = (path.isAbsolute(process.argv[2]))
  ? process.argv[2] : path.resolve(process.cwd(), process.argv[2])
const fileExts = (process.argv[4]) ? process.argv[4].split(',') : ['js']

let outputFilePath = process.argv[3]
// If not output file path was passed, generates a temporary file
if (!outputFilePath) {
  outputFilePath = path.join(
    fs.mkdtempSync('aiies6', 'utf8'),
    `${Date.now()}${Math.round(Math.random(99999) * 100000)}.js`
  )
} else if (!path.isAbsolute(outputFilePath)) {
  outputFilePath = path.resolve(process.cwd(), outputFilePath)
}

try {
  fs.readdirSync(srcDir)
} catch (e) {
  exitWithError(`${e.message}

${HELP_MSG}
`)
}

let relPathOutSrc = relative(path.dirname(outputFilePath), srcDir)
if ((relPathOutSrc[0] !== '.') && (relPathOutSrc[0] !== '/')) {
  relPathOutSrc = `./${relPathOutSrc}`
}

const outputFd = fs.openSync(outputFilePath, 'w+', parseInt('777', 8))
fs.writeSync(outputFd, '// DO NOT MODIFY THIS FILE: AUTOGENERATED BY iigen\n', null, 'utf8')

const filesList = fs.readdirSync(srcDir).filter((fname) => {
  // get the extension of the filename without the '.'
  const ext = path.extname(fname).slice(1)

  return fileExts.find((e) => ext === e) !== undefined
})

// sort to have a deterministic result
filesList.sort()

const exps = []
for (let idx = 0; idx < filesList.length; idx++) {
  const imp = `import * as i${idx} from '${relPathOutSrc}/${filesList[idx]}'\n`

  exps.push(`{ filename: '${filesList[idx]}', exported: i${idx} }`)
  fs.writeSync(outputFd, imp, null, 'utf8')
}

fs.writeSync(outputFd, `export default [${exps.join(', ')}]\n`, null, 'utf8')
fs.closeSync(outputFd)

console.log(outputFilePath)

/** Helper functions **/
function exitWithError (msg) {
  console.error(msg)
  process.exit(1)
}
